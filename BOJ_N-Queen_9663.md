# [BOJ_N-Queen_9663](https://www.acmicpc.net/problem/9663)
***
### Lecture_code
```python

def check(x):                               # x번째 행에 퀸을 배치시킬 수 있는지 검증하는 역할.
    for i in range(x):                      # 현재 행(x번째 행) 이전 모든 행들(0~x-1)의 퀸의 배치를 고려하는데 
        if row[x] == row[i]:                # 위쪽에 다른 퀸들이 배치되어있다면 | x는 현재행, i는 0~x-1로 이전의 모든 행들.    
            return False                    # False를 반환하여 dfs 내에서 해당 위치에 퀸을 배치시킬 수 없음을 알려주고  
        if abs(row[x] - row[i]) == x - i:   # 대각선에 다른 퀸들이 배치되어있다면  
            return False                    # False를 반환하여 dfs 내에서 해당 위치에 퀸을 배치시킬 수 없음을 알려준다.
    return True                             # 위, 대각선 모두 겹치지 않는다면, 배치가능한 위치이므로 True를 반환.


def dfs(x):               # x는 행(행번호).
    global result
    if x == n:            # n번째 행까지 퀸을 배치할 수 있는 곳이 있을 때        
        result += 1
    else:
        for i in range(n):  # x번째 행에 속하는 모든 열에 
            row[x] = i      # 퀸을 배치시켰다고 가정하고
            if check(x):    # x행 이전까지의 행들의 퀸 배치를 check()로 고려하여 배치시킬 수 있다면
                dfs(x + 1)  # 현재 행에 퀸을 배치시킨 후, 다음 행(x+1)으로 넘어가서 다시 탐색을 수행하도록 함. 

n = int(input())
row = [0] * n       # 인덱스를 행 번호, 원소를 열 번호로 갖는 리스트. 
result = 0
dfs(0)              # 첫번째 행(0)부터 탐색 시작.
print(result)
```
|출저|유형|
|:---:|:---:|
|3_ch02_16|DFS, 완전탐색, Backtracking|
* 아이디어: 각 행마다 행에 속한 모든 열에 퀸을 놓은 경우를 고려하는데, 퀸이 이미 배치된 모든 이전 행들(현재 행의 위에 위치한 모든 행들)을 고려해가면서 퀸을 배치. 
* 체스에서 퀸은 상하좌우, 대각선 총 8방향으로 이동 가능. 
* "(1 ≤ N < 15)" 처럼 주어진 범위가 적은 경우, 모든 경우의 수를 고려해야하는 경우가 많다. 
* Backtracking: 가능한 모든 경우를 탐색하면서, 더이상 탐색할 수 없는 경우 이전으로 돌아가서 다른 경우를 다시 탐색하는 알고리즘을 의미.<br/>완전탐색 시 사용되며, BFS, DFS와 같은 맥락.
* 백트래킹은 DFS, BFS로 모두 구현 가능하지만, DFS로의 구현이 편리할 때가 많음. 
* DFS vs BFS: 구현은 DFS가 주로 더 간단하나, 속도는 BFS가 더 빠른 경우가 많음. 
