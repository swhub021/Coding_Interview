# [BOJ_배_1092](https://www.acmicpc.net/problem/1092)
***
### Lecture_code
```python
import sys

n = int(input())
cranes = list(map(int, input().split()))

m = int(input())
boxes = list(map(int, input().split()))

########################################## "만약 모든 박스를 배로 옮길 수 없으면 -1을 출력한다." ###################################

if max(cranes) < max(boxes):  # 가장 무거운 무게를 옮길 수 있는 크레인보다 가장 무거운 박스의 무게가 더 크다면, 옮길 수 없는 박스가 존재한다는 뜻.
    print(-1)
    sys.exit()
    
########################################### 모든 박스를 옮길 수 있는 경우. ######################################################### 

positions = [0] * n         # 각각의 크레인을 인덱스로 하고, 해당 인덱스에 대응되는 크레인이 탐색할 박스의 위치(인덱스)를 원소로 하는 리스트.

checked = [False] * m       # 각각의 박스의 위치를 인덱스로 하고, 해당 인덱스에 대응되는 박스가 옮겨졌는지(1), 아닌지(0)를 원소로 하는 리스트.

cranes.sort(reverse=True)   # 최적의 해를 구해야 하므로, 크레인과 박스 모두 내림차순 정렬.
boxes.sort(reverse=True)

result = 0      # 전체 크레인이 1분 동안 각자 옮길 수 있는 박스를 모두 선택하고 1분이 경과할 때마다 그 시간이 누적될 변수이자 최종 출력값.
count = 0       # while문의 종료 조건에 사용될, 현재까지 옮긴 박스의 개수가 누적될 변수.

while True:                                   # 한 번의 while문 수행 = 1분.
    if count == len(boxes):                   # 종료 조건: 현재까지 옮긴 박스의 개수(count)가 모든 박수의 개수와 같을 때. 
        break
                                              # 34~42)의 for문은 각 크레인마다 자신이 옮길 수 있는 박스를 1개 선택한 후 옮기는 과정.
    for i in range(n):                        # 모든 크레인(인덱스 0~n-1)에 대하여 1분 동안 각각 옮길 수 있는 박스를 선택하고 옮기도록 함.
        while positions[i] < len(boxes):      # 현재 크레인(i)이 옮기기를 고려하는 박스의 위치(positions[i])가 전체 박스의 개수를 넘지 않는 범위인 동안 탐색         
            if not checked[positions[i]] and cranes[i] >= boxes[positions[i]]: # 현재 고려 대상인 박스가 아직 안 옮긴 박스이면서 동시에,
                                                                               # 현재 크레인이 옮길 수 있는 무게의 박스라면, 해당 박스를 옮기게 되므로
                checked[positions[i]] = True  # 해당 박스를 옮겼다고 체크한 후
                positions[i] += 1             # 현재 크레인이 1분 후인 다음 차례에 옮기기를 고려할 박스의 순서가 그 다음 박스가 되도록 +1 
                count += 1                    # 박스를 1개 옮겼으므로 +1을 해서 전체 박스의 개수와 count가 같아지면 종료되도록하고
                break                         # 현재의 크레인은 박스를 옮겼으므로 탐색을 종료하고 다음 크레인이 박스를 고르게 됨.
            positions[i] += 1                 # 현재 크레인이 고려하고 있는 박스가 옮길 수 없는 박스라면, 그 다음 박스를 고려하도록 +1
    result += 1                               # 전체 크레인이 1분 동안 각자 옮길 수 있는 박스를 모두 선택한 후 각자의 박스를 옮겨서 1분이 경과했으므로 +1

print(result)
```
|출저|유형|자료형|시간복잡도|
|:---:|:---:|:---:|:---:|
|3_ch02_14|그리디|list|O(NM): 크레인의 수 x 박스의 수|
* 박스의 무게를 내림차순으로 정렬해서 무거운 박스부터 옮겨야 최적의 해를 보장 가능.
* 매 분마다, 내림차순으로 정렬된 크레인을 기준으로, 각각의 크레인이 옮길 수 있는 박스를 선택하여 박스를 옮긴다.
* 이때 각 크레인은 자신이 다음에 선택할 박스에 대한 정보를 갖도록 하여<br/>자신이 옮길 박스인지에 대한 고려는 한번만 하도록 하여 최적의 해가 보장되록 해야함. 
* 각각의 크레인은 박스들의 무게를 원소로하는 리스트를 앞에서부터 탐색하면서,<br/>자신보다 앞에 있는 그레인들이 선택한 박스와 자신이 들 수 없는 무게의 박스는 제외하고,<br/>나머지 박스들 중 가장 무거운 박스를 선택한다.
* checked = [False] * m, **not checked[positions[i]]**는 checked = [0]*m, checked[positions[i]] == 0 과 같은 의미.
* 옮길 수 있는 박스: 선택의 고려대상이 되고 있는 박스의 무게는 현재 크레인이 옮길 수 있는 무게보다 작거나 같아야 옮길 수 있다.
* cranes[i]: cranes의 원소는 인덱스 i인 크레인이 옮길 수 있는 무게와 같다.
* positions[i]: positions의 원소는 현재 크레인이 옮길지 고려 대상으로 삼는 박스의 인덱스(위치)와 같다.
